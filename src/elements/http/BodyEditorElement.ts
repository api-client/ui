/* eslint-disable lit-a11y/no-autofocus */
/* eslint-disable class-methods-use-this */
/**
@license
Copyright 2020 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
import { LitElement, html, CSSResult, TemplateResult } from 'lit';
import { property } from 'lit/decorators.js';
import '@anypoint-web-components/awc/dist/define/anypoint-dropdown-menu.js';
import '@anypoint-web-components/awc/dist/define/anypoint-listbox.js';
import '@anypoint-web-components/awc/dist/define/anypoint-item.js';
import '@anypoint-web-components/awc/dist/define/anypoint-button.js';
import '@anypoint-web-components/awc/dist/define/anypoint-icon-button.js';
import { EventUtils, IBodyMetaModel, IMultipartBody, IProperty, IRawBody, ISafePayload, PayloadSerializer } from '@api-client/core/build/browser.js';
import { ResizableMixin } from '@anypoint-web-components/awc';
import '../../define/api-icon.js';
import elementStyles from './BodyEditor.styles.js';
import {
  bodyTypeSelectorTemplate,
  bodyTypeOptionsTemplate,
  selectedValue,
  valueValue,
  modelValue,
  editorTemplate,
  rawEditorTemplate,
  urlEncodeEditorTemplate,
  multipartEditorTemplate,
  fileEditorTemplate,
  noEditorTemplate,
  typeChangeHandler,
  pickFileHandler,
  fileChangeHandler,
  notifyInput,
  fileDetailTemplate,
  clearValueHandler,
  readMetaModel,
  setMetaModel,
  urlEncodeChangeHandler,
  multipartChangeHandler,
  modelChanged,
  restoreFileModel,
  rawChangeHandler,
  contentTypeValue,
  analyzeContentType,
  invalidMimeValue,
  invalidMimeMessage,
  invalidMimeTemplate,
  fixableInvalidMimeTemplate,
  autoFixMime,
  monacoTemplate,
  mimeValue,
  mainActionsTemplate,
  mimeTypeChangeHandler,
  dropHandler,
  dragOverHandler,
  enabledEditorsValue,
  effectiveEditorsValue,
  computeEffectiveEditors,
} from './internals.js';
import '../../define/body-formdata-editor.js';
import '../../define/body-multipart-editor.js';
import '../../define/body-raw-editor.js';
import { ifProperty } from '../../directives/if-property.js';
import BodyFormdataEditorElement from './BodyFormdataEditorElement.js';
import BodyRawEditorElement from './BodyRawEditorElement.js';
import BodyMultipartEditorElement from './BodyMultipartEditorElement.js';
import { Events } from '../../events/Events.js';

export declare type AllowedEditor = 'raw' | 'urlEncode' | 'multipart' | 'file';

export interface EditorType {
  id: AllowedEditor;
  label: string;
  title: string;
}

export const editorTypes: Readonly<EditorType[]> = Object.freeze([
  {
    id: 'raw',
    label: 'Raw input',
    title: 'Opens a source editor with syntax highlighting'
  },
  {
    id: 'urlEncode',
    label: 'application/x-www-form-urlencoded',
    title: 'Opens an editor specialized with URL encoded data types'
  },
  {
    id: 'multipart',
    label: 'Multipart form data',
    title: 'Opens an editor specialized with multipart data'
  },
  {
    id: 'file',
    label: 'File',
    title: 'Allows to choose any binary data'
  }
]);

/**
 * @fires change When the value and the model change
 */
export default class BodyEditorElement extends ResizableMixin(LitElement) {
  static get styles(): CSSResult[] {
    return [elementStyles];
  }

  [selectedValue]: AllowedEditor = 'raw';

  /**
   * The currently rendered editor.
   */
  @property({ type: String })
  get selected(): AllowedEditor | undefined {
    return this[selectedValue];
  }

  set selected(value: AllowedEditor | undefined) {
    const old = this[selectedValue];
    if (old === value) {
      return;
    }
    const valid = editorTypes.some((item) => item.id === value);
    if (!valid && value !== null && value !== undefined) {
      return;
    }
    this[selectedValue] = value || 'raw';
    this[analyzeContentType]();
    this.requestUpdate();
  }

  [valueValue]: any = '';

  /**
   * The HTTP body.
   *
   * Depending of current editor selection the type can vary.
   */
  @property()
  get value(): any {
    return this[valueValue];
  }

  set value(value: any) {
    const old = this[valueValue];
    if (old === value) {
      return;
    }
    // this is to be able to set a private filed value from
    // within the element
    this[valueValue] = value;
    this.requestUpdate();
  }

  [modelValue]: IBodyMetaModel[] | undefined;

  /**
   * Previously generated by this editor metadata model.
   * Used internally to set the UI.
   */
  @property({ type: Array })
  get model(): IBodyMetaModel[] | undefined {
    return this[modelValue];
  }

  set model(value: IBodyMetaModel[] | undefined) {
    const old = this[modelValue];
    if (old === value) {
      return;
    }
    // this is to be able to set a private filed value from
    // within the element
    this[modelValue] = value;
    this.requestUpdate();
    this[modelChanged]();
  }

  /**
   * When set the editor is in read only mode.
   */
  @property({ type: Boolean, reflect: true }) readOnly = false;

  /**
   * When set all controls are disabled in the form
   */
  @property({ type: Boolean, reflect: true }) disabled = false;

  /** 
   * When set it automatically encodes and decodes values.
   */
  @property({ type: Boolean, reflect: true }) autoEncode = false;


  /** 
   * When set it ignores the content type processing.
   * This disables option "current header value", in raw editor, and disabled information about 
   * content-type header update.
   */
  @property({ type: Boolean, reflect: true }) ignoreContentType = false;

  /**
   * @returns True when the current value is a file (or blob).
   */
  get hasFile(): boolean {
    const { value } = this;
    return value instanceof Blob;
  }

  [contentTypeValue]?: string;

  /** 
   * The current request content type. It is passed to the `raw` editor
   * to detect current language.
   */
  @property({ type: String, reflect: true })
  get contentType(): string | undefined {
    return this[contentTypeValue];
  }

  set contentType(value) {
    const old = this[contentTypeValue];
    if (old === value) {
      return;
    }
    this[contentTypeValue] = value;
    this[analyzeContentType]();
    this.requestUpdate();
  }

  [enabledEditorsValue]?: string;

  [effectiveEditorsValue]?: readonly EditorType[];

  /** 
   * The list of coma separated names of the editors to enable.
   * This must be the list of `id` values from the available editors.
   * Possible values: `raw,urlEncode,multipart,file`
   */
  @property({ type: String, reflect: true })
  get types(): string | undefined {
    return this[enabledEditorsValue];
  }

  set types(value: string | undefined) {
    const old = this[enabledEditorsValue];
    if (old === value) {
      return;
    }
    this[enabledEditorsValue] = value;
    this[effectiveEditorsValue] = this[computeEffectiveEditors](value);
    this.requestUpdate('types', old);
  }

  /**
   * @returns The final list of editors to render.
   */
  get effectiveEditors(): Readonly<EditorType[]> {
    return this[effectiveEditorsValue] || editorTypes;
  }

  [invalidMimeMessage]?: number;

  [invalidMimeValue]?: boolean;

  [mimeValue]?: string;

  constructor() {
    super();
    this[dropHandler] = this[dropHandler].bind(this);
    this[dragOverHandler] = this[dragOverHandler].bind(this);
  }

  connectedCallback(): void {
    super.connectedCallback();
    this.addEventListener('drop', this[dropHandler]);
    this.addEventListener('dragover', this[dragOverHandler]);
  }

  disconnectedCallback(): void {
    super.disconnectedCallback();
    this.removeEventListener('drop', this[dropHandler]);
    this.removeEventListener('dragover', this[dragOverHandler]);
  }

  /**
   * This must be called only when the `model` property change from the 
   * outside. It restores values depending on the selected editor.
   */
  [modelChanged](): void {
    const { selected, model } = this;
    if (!model) {
      return;
    }
    if (selected === 'file') {
      this[restoreFileModel]();
    }
  }

  /**
   * Restores file value from the model, if exists
   */
  [restoreFileModel](): void {
    const fileModel = this[readMetaModel]('file') as ISafePayload[] | undefined;
    if (!Array.isArray(fileModel) || !fileModel.length) {
      this[valueValue] = '';
      return;
    }
    const [item] = fileModel;
    if (!item || !item.data) {
      this[valueValue] = '';
      return;
    }
    const file = PayloadSerializer.deserializeFile(item);
    this[valueValue] = file;
  }

  /**
   * Dispatches the `input` event
   */
  [notifyInput](): void {
    this.dispatchEvent(new Event('change'));
  }

  /**
   * A handler for the editor selection. It activates an editor, if necessary.
   */
  async [typeChangeHandler](e: CustomEvent): Promise<void> {
    const id = e.detail.selected as AllowedEditor;
    if (this[selectedValue] === id) {
      return;
    }
    this[selectedValue] = id;
    this[analyzeContentType]();
    if (id === 'raw') {
      const model = this[readMetaModel]('raw') as IRawBody[];
      let value = '';
      if (Array.isArray(model) && model.length) {
        value = model[0].value;
      }
      this.value = value;
      this[notifyInput]();
    }
    this.requestUpdate();
    await this.updateComplete;
    this.notifyResize();
    if (id === 'file') {
      this[restoreFileModel]();
      this[notifyInput]();
    } else if (id === 'urlEncode') {
      const editor = this.shadowRoot!.querySelector('body-formdata-editor')!;
      this.value = editor.value;
      this[notifyInput]();
    } else if (id === 'multipart') {
      const editor = this.shadowRoot!.querySelector('body-multipart-editor')!;
      this.value = editor.value;
      this[notifyInput]();
    }
    this.dispatchEvent(new Event('select'));
  }

  /**
   * A handler for the file pick button click.
   * Activates the file input.
   */
  [pickFileHandler](): void {
    const input = this.shadowRoot!.querySelector('.binary-hidden') as HTMLInputElement;
    input.click();
  }

  /**
   * A handler for the file file selection in the file input.
   * Sets the value to the file.
   */
  async [fileChangeHandler](e: Event): Promise<void> {
    const input = e.target as HTMLInputElement;
    const { files } = input;
    const file = files![0];
    if (!file) {
      return;
    }
    this[valueValue] = file;
    const payload = await PayloadSerializer.stringifyFile(file);
    const model = [ payload ];
    this[setMetaModel]('file', model);
    this[notifyInput]();
    this.requestUpdate();
  }

  /**
   * Clears the current value
   */
  [clearValueHandler](): void {
    this.value = '';
    this.model = undefined;
    this[notifyInput]();
  }

  /**
   * Reads editor view model
   * 
   * @param editor The editor id
   * @returns The view model
   */
  [readMetaModel](editor: string): (ISafePayload | IProperty | IMultipartBody | IRawBody)[] | undefined {
    const meta = this.model;
    if (!meta || !Array.isArray(meta)) {
      return undefined;
    }
    const item = meta.find((model) => model.type === editor);
    if (!item) {
      return undefined;
    }
    if (Array.isArray(item.viewModel)) {
      return item.viewModel;
    }
    return undefined;
  }

  /**
   * Sets editor view model on the local model
   * @param editor The editor id
   * @param model The view model
   */
  [setMetaModel](editor: AllowedEditor, model: (ISafePayload | IProperty | IMultipartBody | IRawBody)[]): void {
    if (!Array.isArray(this[modelValue])) {
      this[modelValue] = [];
    }
    const meta = this.model!;
    const index = meta.findIndex((item) => item.type === editor);
    if (index === -1) {
      meta.push({ type: editor, viewModel: model });
    } else {
      meta[index].viewModel = model;
    }
  }

  /**
   * A handler for the change event dispatched by the 
   * `urlEncode` editor.
   * Updated the local value, model, and notifies the change.
   */
  [urlEncodeChangeHandler](e: Event): void {
    const editor = e.target as BodyFormdataEditorElement;
    const { value, model } = editor;
    this[valueValue] = value;
    this[setMetaModel]('urlEncode', model);
    this[notifyInput]();
    // do not request update here.
  }

  /**
   * A handler for the change event dispatched by the `raw` editor.
   * Updated the local value, model, and notifies the change.
   */
  [rawChangeHandler](e: Event): void {
    const editor = e.target as BodyRawEditorElement;
    const { value } = editor;
    this[valueValue] = value;
    const model: IRawBody[] = [{ value }];
    this[setMetaModel]('raw', model);
    this[notifyInput]();
  }

  /**
   * A handler for the change event dispatched by the 
   * `multipart` editor.
   * Updated the local value, model, and notifies the change.
   */
  [multipartChangeHandler](e: Event): void {
    const editor = e.target as BodyMultipartEditorElement;
    const { value, model } = editor;
    this[valueValue] = value;
    this[setMetaModel]('multipart', model);
    this[notifyInput]();
  }

  /**
   * Checks whether the current content type header value matches the selected editor.
   * If not it renders a warning message.
   */
  [analyzeContentType](): void {
    const mime = this[contentTypeValue];
    if (!mime || typeof mime !== 'string') {
      this[invalidMimeValue] = false;
      this[mimeValue] = undefined;
      return;
    }
    let ct = mime;
    const semicolon = ct.indexOf(';');
    if (semicolon !== -1) {
      ct = ct.substring(0, semicolon);
    }
    this[mimeValue] = ct;
    if (!ct) {
      this[invalidMimeValue] = false;
      return;
    }
    const { selected } = this;
    if (selected === 'multipart') {
      if (ct !== 'multipart/form-data') {
        this[invalidMimeValue] = true;
        this[invalidMimeMessage] = 1;
      } else {
        this[invalidMimeValue] = false;
      }
    } else if (selected === 'urlEncode') {
      if (ct !== 'application/x-www-form-urlencoded') {
        this[invalidMimeValue] = true;
        this[invalidMimeMessage] = 2;
      } else {
        this[invalidMimeValue] = false;
      }
    } else {
      this[invalidMimeValue] = false;
    }
  }

  /**
   * Automatically fixes content type problem.
   */
  [autoFixMime](): void {
    const { selected } = this;
    let updated = '';
    if (selected === 'urlEncode') {
      updated = 'application/x-www-form-urlencoded';
    } else if (selected === 'multipart') {
      updated = 'multipart/form-data';
    }
    Events.HttpProject.Request.State.contentTypeChange(updated, this);
  }

  /**
   * A handler for the mime type selection.
   * @param {CustomEvent} e
   */
  [mimeTypeChangeHandler](e: CustomEvent): void {
    const id = e.detail.selected;
    if (this[mimeValue] === id) {
      return;
    }
    Events.HttpProject.Request.State.contentTypeChange(id, this);
  }

  async [dropHandler](e: DragEvent): Promise<void> {
    e.preventDefault();
    const { dataTransfer } = e;
    if (!dataTransfer) {
      return;
    }
    const { files } = dataTransfer;
    if (!files.length) {
      return;
    }
    const file = files[0];
    const { selected } = this;
    if (selected === 'file') {
      this.value = file;
    } else if (selected === 'multipart') {
      const editor = this.shadowRoot!.querySelector('body-multipart-editor')!;
      if (!e.ctrlKey && !e.metaKey) {
        editor.value = new FormData();
      }
      const ps = Array.from(files).map((item) => editor.addFile(item));
      await Promise.all(ps);
    } else {
      const payload = await PayloadSerializer.stringifyBlob(file);
      this.value = payload.data;
      const { type } = file;
      if (type) {
        Events.HttpProject.Request.State.contentTypeChange(type, this);
      }
    }
    this[notifyInput]();
  }

  [dragOverHandler](e: DragEvent): void {
    e.preventDefault();
  }

  /**
   * Handles the change to the `enabledEditors` property and, when set, computes a list of
   * editors to enable in the view. The resulted list of a sublist of the `editorTypes` list.
   */
  [computeEffectiveEditors](list?: string): Readonly<EditorType[]> | undefined {
    if (!list || typeof list !== 'string') {
      return undefined;
    }
    const parts = list.split(',').map((item) => item.trim());
    const result = editorTypes.filter((item) => parts.includes(item.id));
    return Object.freeze(result);
  }

  render(): TemplateResult {
    return html`
    <div class="actions">
      ${this[bodyTypeSelectorTemplate]()}
      ${this[mainActionsTemplate]()}
    </div>
    ${this[invalidMimeTemplate]()}
    <div id="container">
      ${this[editorTemplate]()}
    </div>
    `;
  }

  /**
   * @returns The template for the dropdown menu for the editor type
   */
  [bodyTypeSelectorTemplate](): TemplateResult {
    const { disabled, selected } = this;
    return html`
    <anypoint-dropdown-menu
      noLabelFloat
      ?disabled="${disabled}"
      title="Select editor type"
      @select="${EventUtils.cancelEvent}"
    >
      <label slot="label">Editor type</label>
      <anypoint-listbox
        slot="dropdown-content"
        attrforselected="data-type"
        .selected="${selected}"
        ?disabled="${disabled}"
        @activate="${this[typeChangeHandler]}"
      >
        ${this[bodyTypeOptionsTemplate]()}
      </anypoint-listbox>
    </anypoint-dropdown-menu>
    `;
  }

  /**
   * @returns The template for the main editor actions.
   */
  [mainActionsTemplate](): TemplateResult | string {
    const { selected, disabled, ignoreContentType } = this;
    if (selected !== 'raw') {
      return '';
    }
    const mode = this[mimeValue];
    return html`
    <div class="main-actions">
      <anypoint-dropdown-menu
        noLabelFloat
        ?disabled="${disabled}"
        title="Select media type. This overrides the content-type header"
        @select="${EventUtils.cancelEvent}"
      >
        <label slot="label">Mime type</label>
        <anypoint-listbox
          slot="dropdown-content"
          attrforselected="data-type"
          .selected="${mode}"
          ?disabled="${disabled}"
          @activate="${this[mimeTypeChangeHandler]}"
        >
          ${ignoreContentType ?
        html`<anypoint-item data-type="" title="Do not use any formatting">None</anypoint-item>` :
        html`<anypoint-item data-type="" title="Inherited from the headers">Current headers value</anypoint-item>`}
          <anypoint-item data-type="application/json">JSON</anypoint-item>
          <anypoint-item data-type="application/xml">XML</anypoint-item>
          <anypoint-item data-type="text/html">HTML</anypoint-item>
          <anypoint-item data-type="text/css">CSS</anypoint-item>
        </anypoint-listbox>
      </anypoint-dropdown-menu>
    </div>
    `;
  }

  [bodyTypeOptionsTemplate](): TemplateResult {
    const { effectiveEditors } = this;
    return html`
    ${effectiveEditors.map((info) => html`<anypoint-item data-type="${info.id}" title="${info.title}">${info.label}</anypoint-item>`)}
    `;
  }

  /**
   * @returns A template for currently rendered editor
   */
  [editorTemplate](): TemplateResult {
    switch (this.selected) {
      case 'raw': return this[rawEditorTemplate]();
      case 'urlEncode': return this[urlEncodeEditorTemplate]();
      case 'multipart': return this[multipartEditorTemplate]();
      case 'file': return this[fileEditorTemplate]();
      default: return this[noEditorTemplate]();
    }
  }

  /**
   * @returns The template for the raw editor
   */
  [rawEditorTemplate](): TemplateResult {
    let { value } = this;
    const model = this[readMetaModel]('raw') as IRawBody[];
    const hasModel = Array.isArray(model) && model.length;
    if (typeof value !== 'string') {
      value = '';
    }
    if (!value && hasModel) {
      const [item] = model;
      value = item.value;
    }
    return this[monacoTemplate](value);
  }

  /**
   * @param value The editor value
   * @returns The template for the Monaco editor
   */
  [monacoTemplate](value: string): TemplateResult {
    const { contentType } = this;
    return html`
    <body-raw-editor 
      .value="${value}" 
      .contentType="${contentType}"
      @change="${this[rawChangeHandler]}"
    ></body-raw-editor>`;
  }

  /**
   * @returns A template for the application/x-www-form-urlencoded editor
   */
  [urlEncodeEditorTemplate](): TemplateResult {
    const { autoEncode, value } = this;
    const model = /** @type ApiType[] */ (this[readMetaModel]('urlEncode'));
    // when the model is generated for the view then the value should not be set
    // as it would override the previously generated model.
    const effectiveValue = model ? undefined : value;
    return html`
      <body-formdata-editor 
        ?autoEncode="${autoEncode}"
        .value="${ifProperty(effectiveValue)}"
        .model="${ifProperty(model)}"
        @change="${this[urlEncodeChangeHandler]}"
      ></body-formdata-editor>
    `;
  }

  /**
   * @returns A template for the multipart editor
   */
  [multipartEditorTemplate](): TemplateResult {
    const { value, ignoreContentType } = this;
    const model = this[readMetaModel]('multipart') as IMultipartBody[];
    // when the model is generated for the view then the value should not be set
    // as it would override the previously generated model.
    const effectiveValue = model ? undefined : value;
    return html`
      <body-multipart-editor 
        .value="${ifProperty(effectiveValue)}"
        .model="${ifProperty(model)}"
        ?ignoreContentType="${ignoreContentType}"
        @change="${this[multipartChangeHandler]}"
      ></body-multipart-editor>
    `;
  }

  /**
   * @returns A template for the file input editor
   */
  [fileEditorTemplate](): TemplateResult {
    const { ignoreContentType } = this;
    return html`
    <anypoint-button emphasis="medium" @click="${this[pickFileHandler]}">Choose a file</anypoint-button>
    ${this[fileDetailTemplate]()}
    <input type="file" class="binary-hidden" @change="${this[fileChangeHandler]}"/>
    ${ignoreContentType ? '' : html`<p class="mime-info">
      <api-icon icon="info" class="info"></api-icon>
      The content-type header will be updated for this request when the HTTP message is generated.
    </p>`}
    `;
  }

  /**
   * @returns A template for the missing selection
   */
  [noEditorTemplate](): TemplateResult {
    return html`<div class="empty-editor"></div>`;
  }

  /**
   * @returns A template for the file details.
   */
  [fileDetailTemplate](): TemplateResult | string {
    if (!this.hasFile) {
      this[restoreFileModel]();
    }
    if (!this.hasFile) {
      return '';
    }
    const { value } = this;
    const { size, name } = value as File;
    return html`
    <div class="section-title file-padding">Selected file</div>
    <div class="file-info">
      <span class="file-name">${name || 'unknown name'}</span>
      <span class="file-size">${size} bytes</span>
      <anypoint-icon-button
        class="action-icon delete-icon"
        title="Remove file"
        @click="${this[clearValueHandler]}"
        aria-label="Activate to remove the file"
      >
        <api-icon icon="remove"></api-icon>
      </anypoint-icon-button>
    </div>
    `;
  }

  [invalidMimeTemplate](): TemplateResult | string {
    if (!this[invalidMimeValue]) {
      return '';
    }
    const id = this[invalidMimeMessage];
    return html`
    <div class="invalid-mime">
      <api-icon icon="warning" class="warning-icon"></api-icon>
      ${id === 1 ? this[fixableInvalidMimeTemplate]('multipart/form-data') : ''}
      ${id === 2 ? this[fixableInvalidMimeTemplate]('application/x-www-form-urlencoded') : ''}
    </div>
    `;
  }

  /**
   * @returns A template for fixable mime type mismatch message.
   */
  [fixableInvalidMimeTemplate](suggested: string): TemplateResult {
    return html`
      <p class="message">
        The <code>content-type</code> header has different value than <b>${suggested}</b>.
      </p>
      <anypoint-button class="fix" title="Updates the content type header for the request" @click="${this[autoFixMime]}">Fix</anypoint-button>
    `;
  }
}
